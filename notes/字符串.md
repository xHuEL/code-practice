# 字符串

## 单字符

1. <b>回文串</b>

   [回文子串](https://leetcode.cn/problems/palindromic-substrings/) —— [提交记录](../code/palindromic-substrings.py)

   [最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/?envType=problem-list-v2&envId=string) —— [提交记录](../code/longest-palindromic-substring.py)

   基本思路都是一样的。假如给定的字符串为abbbba, 分为两种情况来考虑：(1) 回文串是偶数长度，枚举回文串中心[i, i + 1], 然后分别向左右进行扩展，计算出这个中心得到的最长回文串。对于abbbba而言，就是枚举位置[0, 1] - ab ,[1, 2] - bb, [2, 3] - bb,[3, 4] - bb,[4, 5] - ba, 然后分别让左右扩展，计算出来的最长回文串分别为ab, bb,abbbba,bb, ba  (2) 回文串是奇数长度，枚举回文串中心[i]  (在实现上会将这个中心抽象成[i, i])，然后分别向左右进行扩展，计算出该字符作为中心得到的最长回文串。对于abbbba而言，就是枚举位置[0] a, [1] b, [2] b, [3] b, [4] b, [5] a, 然后分别向左右扩展，计算出来的最长回文串为a,b,bbb,bbb,b,a

   对于第一题而言，是计算回文子串的数量，那么就是在以[i, i+1]或者[i]为中心进行扩展的时候，使用一个cnt来进行累加（题外话：可能题目会有一些变化，比如计算出不同回文子串的数量，这个时候可以使用dict来进行去重）；对于第二题而言，是计算出最长回文子串，就是在以[i, i+1]或者[i]为中心进行扩展的时候，使用一个cnt来进行最大值计数。

   不需要掌握的知识点：最长回文子串有特定的线性算法[[马拉车算法](https://zhuanlan.zhihu.com/p/70532099)],还有一个更强大的数据结构[[回文树](https://zhuanlan.zhihu.com/p/581946378)]可以用来求回文子串的数量

2. <b>动态规划</b>

   [最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/) —— [提交记录](../code/longest-palindromic-subsequence.py)

   [最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/description/) —— [提交记录](../code/longest-valid-parentheses.py)

   （1） 对于单一字符串而言，这类题目本质是一样的：找到满足条件的子串或者子序列，对于子串思路会比较复杂点（可能涉及到滑动窗口、动态规划等）；对于子序列而言，大概率就是动态规划，动态规划理解起来可能比较难，但是就是怎么用编程语言(for循环)来表示状态转移方程

   对于最长回文子序列而言，状态转移方程为:

   ![QianJianTec1767655469387](pic\最长回文子序列状态转移方程.png)

​       在实现的过程中：枚举i 和 j之间的差值step = (j - i), 然后按照公式计算就行了。为什么要枚举step，主要是为了保证在计算f(i, j)的时候，f(i + 1, j - 1)已经被计算出来。

```python
        for step in range(2, n):
            for i in range(n):
                j = i + step
                if j >= n:
                    continue

                dp[i][j] = max(dp[i + 1][j], dp[i][j])
                dp[i][j] = max(dp[i][j - 1], dp[i][j])
                if s[i] == s[j]:
                    dp[i][j] = max(dp[i + 1][j - 1] + 2, dp[i][j])
```

​      (2)  最长有效括号

  

## 两个字符

## 多个字符

