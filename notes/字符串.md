# 字符串

## 单字符

1. <b>回文串</b>

   [回文子串](https://leetcode.cn/problems/palindromic-substrings/) —— [提交记录](../code/palindromic-substrings.py)

   [最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/?envType=problem-list-v2&envId=string) —— [提交记录](../code/longest-palindromic-substring.py)

   基本思路都是一样的。假如给定的字符串为abbbba, 分为两种情况来考虑：(1) 回文串是偶数长度，枚举回文串中心[i, i + 1], 然后分别向左右进行扩展，计算出这个中心得到的最长回文串。对于abbbba而言，就是枚举位置[0, 1] - ab ,[1, 2] - bb, [2, 3] - bb,[3, 4] - bb,[4, 5] - ba, 然后分别让左右扩展，计算出来的最长回文串分别为ab, bb,abbbba,bb, ba  (2) 回文串是奇数长度，枚举回文串中心[i]  (在实现上会将这个中心抽象成[i, i])，然后分别向左右进行扩展，计算出该字符作为中心得到的最长回文串。对于abbbba而言，就是枚举位置[0] a, [1] b, [2] b, [3] b, [4] b, [5] a, 然后分别向左右扩展，计算出来的最长回文串为a,b,bbb,bbb,b,a

   对于第一题而言，是计算回文子串的数量，那么就是在以[i, i+1]或者[i]为中心进行扩展的时候，使用一个cnt来进行累加（题外话：可能题目会有一些变化，比如计算出不同回文子串的数量，这个时候可以使用dict来进行去重）；对于第二题而言，是计算出最长回文子串，就是在以[i, i+1]或者[i]为中心进行扩展的时候，使用一个cnt来进行最大值计数。

   不需要掌握的知识点：最长回文子串有特定的线性算法[[马拉车算法](https://zhuanlan.zhihu.com/p/70532099)],还有一个更强大的数据结构[[回文树](https://zhuanlan.zhihu.com/p/581946378)]可以用来求回文子串的数量

2. <b>动态规划</b>

   [最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/) —— [提交记录](../code/longest-palindromic-subsequence.py)

   [最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/description/) —— [提交记录](../code/longest-valid-parentheses.py)

   （1）最长回文子序列

    对于单一字符串而言，这类题目本质是一样的：找到满足条件的子串或者子序列，对于子串思路会比较复杂点（可能涉及到滑动窗口、动态规划等）；对于子序列而言，大概率就是动态规划，动态规划理解起来可能比较难，实际就是怎么用编程语言(for循环)来表示状态转移方程

   对于最长回文子序列而言，状态转移方程为:
   
   ![QianJianTec1767655469387](./pic/最长回文子序列状态转移方程.png)

​       在实现的过程中：枚举i 和 j之间的差值step = (j - i), 然后按照公式计算就行了（具体实现如下）—— 为什么要枚举step，主要是为了保证在计算f(i, j)的时候，f(i + 1, j - 1)已经被计算出来。

```python
        for step in range(2, n):
            for i in range(n):
                j = i + step
                if j >= n:
                    continue

                dp[i][j] = max(dp[i + 1][j], dp[i][j])
                dp[i][j] = max(dp[i][j - 1], dp[i][j])
                if s[i] == s[j]:
                    dp[i][j] = max(dp[i + 1][j - 1] + 2, dp[i][j])
```

​      (2)  最长有效括号

​	       这道题严格意义上来不算是动态规划。对于括号匹配问题（更一般的：序列中的二元匹配问题），第一反应就是使用堆栈来实现。对于括号()())，堆栈记录的是每个(的位置，比如想找到倒数第二个’）‘对应的’（‘的位置，堆栈的变化如下（使用pos[i], 来记录字符')'匹配的'('的位置，其中i为字符')'的位置）：

位置0, 遍历到(,  位置0入栈，stack = [0]

位置1, 遍历到)，stack = [0], 0出栈赋值给pos[1]，此时pos[0] = 1, stack = []

位置2，遍历到(，stack = [2]

位置3, 遍历到）,stack = [2], 2出栈赋值给pos[3]，此时pos[3] = 2, stack = []

位置4，遍历到(，stack = [4]

所以倒数第二个')'对应的’('的位置，为pos[3] = 2

```python
stk = [0 for c in s]
top = 0

ans = 0
for index, c in enumerate(s):
    if c == ')':
   
        if top == 0:
            top = 0
            continue
        else:
            match_pos = stk[top - 1]
            top = top - 1
            pos[index] = match_pos
    else:
        stk[top] = index
        top = top + 1
return ans
```

回到这个题目，对于字符串()(((())))，使用上面方法可以找到每个字符')'的匹配'('的位置，我们只需要添加一个辅助数组dp[i]记录当前‘)'为结尾的最长有效括号长度是多少就可以，可以得到下面的转移方程

![最长有效括号长度](./pic/最长有效括号长度.png)

具体实现如下：

```python
def longestValidParentheses(self, s: str) -> int:
    ## 堆栈只会压入'('
    stk = [0 for c in s]
    top = 0
    dp = [0 for _ in s]

    ## 当前匹配到的括号的长度
    ans = 0
    for index, c in enumerate(s):
        if c == ')':
            ## 堆栈为空，不压入c
            if top == 0:
                top = 0
                continue
            else:
                pos = stk[top - 1]
                top = top - 1
                dp[index] = dp[pos - 1] + (index - pos + 1)
                if dp[index] > ans:
                    ans = dp[index]
        else:
            stk[top] = index
            top = top + 1
    return ans
```

3. <b>字符串哈希</b>

   [字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

   

## 两个字符

## 多个字符

